Mapper工作模式说明

以下规则定义仅对应v1.3的Schematic/PCB/CPLD实现

主功能模式包含4种大模式(6种小模式)
    * 透传模式
    * 一般的MBC1
    * MemoryBackup卡的GameCart模式
    * MemoryBackup卡的MemoryBackup模式，这个又有2类子模式(或者打平，可以看成3种子模式)
        * ROM子模式
            * PRG ROM子模式
            * Storage ROM子模式
        * RAM子模式

主功能模式的各种模式切换方式
    0. 透传模式
        启动时，开关放在透传档(Off档)
    1. 等同一般的MBC1:
        往0x2000写入'b'0xxxxxxx,即($00 | BankID), bit6和bit5忽略
        启动时，开关放在On档，默认就是该模式，相当于往0x2000写入'b'00000000
    2. 映射到顶部扩展卡(MemoryBackup卡的GameCart模式)
        往0x2000写入'b'11xxxxxx,即($C0 | BankID), bit5忽略
    3. ROM子模式1,PRG ROM子模式(MemoryBackup卡的MemoryBackup模式)
        往0x2000写入'b'101xxxxx,即($A0 | BankID)
    4. ROM子模式2,Storage ROM子模式(MemoryBackup卡的MemoryBackup模式)
        往0x2000写入'b'100xxxxx,即($80 | BankID)
    5. RAM子模式(MemoryBackup卡的MemoryBackup模式)
        往0x0000写入'b'00000100,即$04
    注意:
        1. 编号1-4的模式，在切换模式的同时还同时改写了对应ROM的Bank ID，因为是只写寄存器，所以应用程序自身有责任记录最后一次设置的Bank ID。
        2. 编号5的RAM子模式，有以下注意点:
            2.1 因为不含有RAM Bank ID的设置，需要额外调用0x4000和0x6000进行设置。
            2.2 又因为一旦切换到编号2-5的任意一种模式，都会造成0x4000和0x6000的寄存器写入被禁止，所以每次设置RAM子模式下的RAM Bank ID必须按以下顺序:
                * 为启用0x4000和0x6000寄存器，切换到编号1的模式(往0x2000写入'b'0xxxxxxx)
                * 往0x6000写入1，启用0x4000的寄存器
                * 往0x4000写入BankID
                * 切换到RAM子模式(往0x0000写入$04)
        3. 关于0x0000寄存器的注意点
            3.1 虽然编号5的RAM子模式是通过往0x0000写入$04来完成，
                但是往0x0000再次写入$00或者$0A或者其他值，并不会关闭这个映射，只会改变0xA000部分是否映射到RAM。
                只有通过切换到编号1-4的模式才能切出编号5的RAM子模式。
            3.2 在编号1的"等同一般的MBC1"模式下:
                往0x0000写入$00或者$0A只是改变0xA000部分是否映射到RAM，并不改变模式。
                往0x0000写入$04会改变模式到模式编号5的RAM子模式去，此时，现有的0xA000部分的映射也会受到影响，具体看下面的"次功能模式的各种模式切换方式"。

次功能模式(S-RAM的启用模式)
    * 不启用模式
        不映射RAM当前选中Bank ID到0xA000-0xBFFF
    * 启用模式
        映射RAM当前选中Bank ID到0xA000-0xBFFF

次功能模式的各种模式切换方式
    * 不启用模式
        往0x0000写入'b'xxxx1010以外的值，即$xA以外的值，一般写入$x0。
    * 启用模式
        往0x0000写入'b'xxxx1010，即$xA。
    注意:
        1. 因为0x0000写入$x4时还兼作了切换到RAM子模式，此时次功能模式会被切换到"不启用模式"
           所以如果需要同时把某片RAM的Bank同时映射到0x4000-0x7FFF和0xA000-0xBFFF，需要按以下顺序:
                * 为启用0x4000和0x6000寄存器，切换到编号1的模式(往0x2000写入'b'0xxxxxxx)
                * 往0x6000写入1，启用0x4000的寄存器
                * 往0x4000写入BankID
                * 切换到RAM子模式(往0x0000写入$04)
                * 次功能模式切换到"启用模式"(往0x0000写入$0A)

从映射逻辑角度，不同模式的差异
    0x0000-0x3FFF
        0. 透传模式
            读写时，映射到顶部卡的同地址
        1. 等同一般的MBC1:
            读取时映射到PRG ROM的Bank 0
            写入0x0000-0x1FFF时，由当前卡的CPLD处理寄存器操作
            写入0x2000-0x3FFF时，由当前卡的CPLD处理寄存器操作
        2. 映射到顶部扩展卡(MemoryBackup卡的GameCart模式)
            读取时映射到PRG ROM的Bank 0(注意，虽然模式名称叫"映射到顶部扩展卡"，但是不映射低于0x4000的部分)
            写入0x0000-0x1FFF时，映射到顶部卡的0x0000-0x1FFF
            写入0x2000-0x3FFF时，由当前卡的CPLD处理寄存器操作
        3. ROM子模式1,PRG ROM子模式(MemoryBackup卡的MemoryBackup模式)
            读取时映射到PRG ROM的Bank 0
            写入0x0000-0x1FFF时，由当前卡的CPLD处理寄存器操作
            写入0x2000-0x3FFF时，由当前卡的CPLD处理寄存器操作
        4. ROM子模式2,Storage ROM子模式(MemoryBackup卡的MemoryBackup模式)
            同上述编号3的模式
        5. RAM子模式(MemoryBackup卡的MemoryBackup模式)
            同上述编号3的模式
    0x4000-0x7FFF
        0. 透传模式
            读写时，映射到顶部卡的同地址
        1. 等同一般的MBC1:
            读取时映射到PRG ROM的指定Bank ID(但是无法做到判断Bank ID为0时映射等同于Bank ID为1)
            写入0x4000-0x5FFF时，由当前卡的CPLD处理寄存器操作
            写入0x6000-0x7FFF时，由当前卡的CPLD处理寄存器操作
        2. 映射到顶部扩展卡(MemoryBackup卡的GameCart模式)
            读写时，映射到顶部卡的0x4000-0x7FFF
        3. ROM子模式1,PRG ROM子模式(MemoryBackup卡的MemoryBackup模式)
            读写时，映射到PRG ROM指定的Bank ID
        4. ROM子模式2,Storage ROM子模式(MemoryBackup卡的MemoryBackup模式)
            读写时，映射到Storage ROM指定的Bank ID
        5. RAM子模式(MemoryBackup卡的MemoryBackup模式)
            读写时，映射到RAM指定的Bank ID
    0xA000-0xBFFF
        0. 透传模式
            读写时，映射到顶部卡的同地址
        1. 等同一般的MBC1:
            如果之前对0x0000写入过$0A,读写时映射到当前卡RAM的指定Bank ID
            如果之前对0x0000写入过非$0A的值,则无有效片选输出
        2. 映射到顶部扩展卡(MemoryBackup卡的GameCart模式)
            读写时，映射到顶部卡的0xA000-0xBFFF
        3. ROM子模式1,PRG ROM子模式(MemoryBackup卡的MemoryBackup模式)
            同上述编号1的模式
        4. ROM子模式2,Storage ROM子模式(MemoryBackup卡的MemoryBackup模式)
            同上述编号1的模式
        5. RAM子模式(MemoryBackup卡的MemoryBackup模式)
            同上述编号1的模式

主功能模式的模式寄存器规划
    * 全局共以下寄存器用于主功能模式
        * SW_1_OnPower_n
            * 记录是否通电时开关在On档(低电平表示开关在On档)
            * 直接用于区分是模式编号0，还是模式编号1-5。
                为高电平表示开关在Off档，即模式编号0。
                为低电平表示开关在On档，即模式编号1-5。
            * 这么安排的原因主要是因为，程序在运行期间，可以在模式编号1-5之间切换，
                但永远不会在运行期间从模式编号0切换到模式编号1-5，或者从模式编号1-5切换到模式编号0。
        * [PrimaryMode_B2..0]
            共3个bit，记录主功能模式的编号。
            将3个bit值当作一个3bit的二进制数看待，用于对应模式编号1-5。
            对应关系如下:
            1. 等同一般的MBC1:
                [PrimaryMode_B2..0] = 'b'000
            2. 映射到顶部扩展卡(MemoryBackup卡的GameCart模式)
                [PrimaryMode_B2..0] = 'b'001
            3. ROM子模式1,PRG ROM子模式(MemoryBackup卡的MemoryBackup模式)
                [PrimaryMode_B2..0] = 'b'010
            4. ROM子模式2,Storage ROM子模式(MemoryBackup卡的MemoryBackup模式)
                [PrimaryMode_B2..0] = 'b'011
            5. RAM子模式(MemoryBackup卡的MemoryBackup模式)
                [PrimaryMode_B2..0] = 'b'1xx
                只要PrimaryMode_B2位为1就被认为是编号5的RAM子模式，低2位的值无所谓。
    * 注意:
        因为编号5的RAM子模式只识别PrimaryMode_B2位，所以进入该模式时无需清理PrimaryMode_B1和PrimaryMode_B0位。
        但是反过来，进入编号1-4的模式时，必须清理PrimaryMode_B2位，否则会被认为是编号5的RAM子模式。
    * 综合起来共占用4个寄存器
    * 各个寄存器的D触发器值变化条件或者clock条件
        * SW_1_OnPower_n的比较简单，就是卡槽的/RST信号
        * PrimaryMode_B2的比较复杂，需要监测0x2000写入和0x0000写入
            因为要在写入0x0000时，如果值不为$x4就不影响现有PrimaryMode_B2值，
            又要在写入0x2000时无条件清空PrimaryMode_B2值，
            所以比较方便的方法是用上.AP异步置位和.AR异步清除
            * 用.AP置位PrimaryMode_B2位的条件：写入0x0000时，且写入值为$x4。
            * 用.AR清除PrimaryMode_B2位的条件：任意值写入0x2000时。
            * 注意: 实际用1502的fitter时，发现必须要赋予寄存器以.ck信号。
                    所以这里的.AP的逻辑还是应该直接用了.ck和.d来实现。
                    额外要加一个条件就是当PrimaryMode_B2已经是1时，不管写入什么到0x0000都要维持当前值。
        * [PrimaryMode_B1..0]的只需要检测0x2000写入
            因为写入0x2000时，无论写入值为多少，[PrimaryMode_B1..0]这两个bit位值必然会受到影响，
            这就和PrimaryMode_B2的值在写入某些值到0x0000时，不会受到影响的情况不同，
            所以既可以用.AP和.AR来完成，也可以用纯粹的.CK和.D来完成。

次功能模式的模式寄存器规划
    * 全局共以下寄存器用于次功能模式
        * SecondaryMode(也可以叫作RAM_Axxx_MAPPING_ENABLE_REG)
            为低电平表示次功能模式的"不启用模式"
            为高电平表示次功能模式的"启用模式"，把RAM当前Bank ID映射到0xA000-0xBFFF
    * 综合起来共占用1个寄存器
    * 各个寄存器的D触发器值变化条件或者clock条件
        * SecondaryMode的只需要检测0x0000写入
            因为写入0x2000时，无论写入值为多少，SecondaryMode这个bit位值必然会受到影响，
            所以既可以用.AP和.AR来完成，也可以用纯粹的CLK和D来完成。
            * 用.AP和.AR完成:
                * 用.AP置位SecondaryMode位的条件：写入0x0000时，且写入值为$xA。
                * 用.AR清除SecondaryMode位的条件：写入0x0000时，且写入值不为$xA。
            * 用.CK和.D来完成
                * 触发时钟.CK条件：写入0x0000时
                * 数据.D的值：写入数据总线的值为$xA时，D为高电平，否则为低电平。

和MBC1的区别汇总
    * 不支持512KB以上的ROM。PRG ROM目前只有512KB所以没有512KB以上的Mapping，0x4000-0x5FFF寄存器的Banking切换全部只针对RAM。
    * RAM的高地址线增加。原版MBC1只有2bit输出，现在有3bit。
    * 特定寄存器不再是无条件可写入
        * 0x4000-0x5FFF的I/O寄存器，在编号1以外的模式下不可以写入，对这个地址范围写入，是应用到对应模式下映射的ROM或者RAM中去。
        * 0x6000-0x7FFF的I/O寄存器，在编号1以外的模式下不可以写入，对这个地址范围写入，是应用到对应模式下映射的ROM或者RAM中去。
    * 0x0000-0x1FFF的寄存器功能扩增。利用了原来未使用的值$x4，实现了RAM映射到0x4000-0x7FFF的功能。
    * 0x2000-0x3FFF的寄存器方面的差异
        * 功能扩增，利用了原版MBC1忽略的高3bit，实现了4种模式的区分。
        * 写入$00时，原版MBC1是把ROM Bank 1映射到0x4000-0x7FFF，现在是把RAM Bank 0映射到0x4000-0x7FFF。

已知问题
    * v1.3版布线和对应PCB设计的问题
        * 因为对PRG ROM的高地址锁存在外部的一个74HC373，所以无法做到切换PRG ROM在0x4000-0x7FFF访问时对应的Bank而又不影响通过0x0000-0x3FFF进行读取时的映射。
          这会导致切换PRG ROM的Bank时，一定要保证切换代码在主机内存中执行，否则因为Bank变化会导致执行的代码所在的ROM也被切到其他区域，进而导致后一条指令变为其他Bank中的，导致逻辑错误。
          这样也就意味着可用性大减，写PRG ROM的Banking逻辑必须无比小心。而且会导致大于16KB的MBC1的游戏实际无法按照预期运行。
        * 要解决这个问题，保证0x0000-0x3FFF的读取映射不受到影响，那么有2种方法：
            1. 把PRG ROM的切换Bank的功能内置到CPLD内去，完全在CPLD内实现PRG ROM的Banking逻辑。
                优点: 可以节省掉一个74HC373和对应的退耦电容。且因为内置逻辑到了CPLD，就可以做到原版MBC1的对0x4000-0x5FFF的I/O写入0时，当作1处理的逻辑，完美实现MBC1这种情况下特殊处理的逻辑仿真。
                缺点: CPLD需要额外5个脚存放PRG ROM的[A18..14]，目前没有使用的A12-A7共有6个脚，所以还是可以的，但是就无法留出脚给未来的SD卡读写功能了。
            2. 给PRG ROM的[A18..14]加上拉低电阻，然后对PRG ROM的74HC373的/OE加上逻辑控制，访问0x0000-0x3FFF时，把/OE拉高。
                优点: 只需要CPLD额外1个脚来控制74HC373的/OE。
                缺点: 需要额外5个拉低电阻。

刷写PRG ROM时的步骤
    * PRG ROM映射在0x0000-0x3FFF的部分是只读的。
    * PRG ROM映射在0x4000-0x7FFF的部分是可读写的。
    * 所以刷写逻辑是依次切换各个Bank到0x4000-0x7FFF，然后再刷写，512KB的ROM全部写满总共需要切换32次。
    * 假设PRG ROM采用512KB的AT29C040(A)或28SF040(A)，这两种芯片的Flash指令都需要用到A14，所以一般按以下步骤来。
        * 以28SF040(A)为例的写入步骤:
            1. [A18..14]切到对应Bank: [0x2000] = 'b'101xxxxx。
            2. 对28SF040(A)发送解锁指令(参考28SF040的datasheet): 依次读取$5823,$5820,$5822,$4418,$441B,$4419,$441A。
            3. 按需擦除需要写入的Sector:
                * [0x4000] = $20                // 写入地址不一定要是0x4000，其实0x4000-0x7FFF都可以。
                * [0x4000 + (X << 8)] = $D0     // X为Bank内的Sector编号，按256字节一个Sector，一个Bank最多$40个Sector，从$0-$3F。
                * 注意等待Toggle Bit变化，然后再继续下一个Sector的擦除。
            4. 写入一个Sector的256字节数据:
                * [0x4000] = $10                // 写入地址不一定要是0x4000，其实0x4000-0x7FFF都可以。
                * [0x4000 + (X << 8) + Y] = $Z  // X为Bank内的Sector编号，具体看上方的Sector擦除指令说明。
                                                // Y为Sector内地址偏移，按256字节一个Sector，Y的取值从$0-$FF。
                                                // Z是具体要写入这个地址的字节值，Z的取值从$0-$FF。
                * 注意等待Toggle Bit变化，然后再继续下一个Byte的写入。
            5. 如果还有下一个Bank需要写入，那么循环到步骤1执行。如果全部Bank写入完成，则到下一步骤。
            6. [A18..14]切到第0个Bank: [0x2000] = 'b'10100000。
            7. 对28SF040(A)发送加锁指令(参考28SF040的datasheet): 依次读取$5823,$5820,$5822,$4418,$441B,$4419,$440A。
            8. 完成。
        * 以AT29C040A为例的写入步骤(这个芯片的写入指令和逻辑流程与28SF040不太一样，而且发指令时用到了A14):
            1. 解锁AT29C040A:
                * [0x5555] = $AA
                    * [A18..14]切到第1个Bank，使A14为1: [0x2000] = 'b'10100001
                    * [0x4000 + 0x1555] = $AA
                * [0x2AAA] = $55
                    * [A18..14]切到第0个Bank，使A14为0: [0x2000] = 'b'10100000
                    * [0x4000 + 0x2AAA] = $55
                * [0x5555] = $80
                    * [A18..14]切到第1个Bank，使A14为1: [0x2000] = 'b'10100001
                    * [0x4000 + 0x1555] = $80
                * [0x5555] = $AA
                    * [A18..14]切到第1个Bank，使A14为1: [0x2000] = 'b'10100001
                    * [0x4000 + 0x1555] = $AA
                * [0x2AAA] = $55
                    * [A18..14]切到第0个Bank，使A14为0: [0x2000] = 'b'10100000
                    * [0x4000 + 0x2AAA] = $55
                * [0x5555] = $20
                    * [A18..14]切到第1个Bank，使A14为1: [0x2000] = 'b'10100001
                    * [0x4000 + 0x1555] = $20
            2. 切换到对应Bank: [0x2000] = 'b'101xxxxx。
            3. 按Sector连续写入256字节(AT29C040是连续写入512字节):
                * [0x4000 + (X << 8) + Y] = $Z  // X为Bank内的Sector编号，按256字节一个Sector，一个Bank最多$40个Sector，从$0-$3F。
                                                // Y为Sector内地址偏移，按256字节一个Sector，Y的取值从$0-$FF。
                                                // Z是具体要写入这个地址的字节值，Z的取值从$0-$FF。
                * 等待Toggle Bit变化，然后再继续下一个Sector的写入。
            4. 如果还有下一个Bank需要写入，那么循环到步骤2执行。如果全部Bank写入完成，则到下一步骤。
            5. 完成。
                * 注意，这种情况下完成后，其实芯片是解锁状态。如果需要是加锁状态，则第4步执行到最后一个Sector时参考步骤6
            6. 如果期望芯片最后是加锁的，那么最后一个Sector写入前执行加锁指令:
                * [0x5555] = $AA
                    * [A18..14]切到第1个Bank，使A14为1: [0x2000] = 'b'10100001
                    * [0x4000 + 0x1555] = $AA
                * [0x2AAA] = $55
                    * [A18..14]切到第0个Bank，使A14为0: [0x2000] = 'b'10100000
                    * [0x4000 + 0x2AAA] = $55
                * [0x5555] = $A0
                    * [A18..14]切到第1个Bank，使A14为1: [0x2000] = 'b'10100001
                    * [0x4000 + 0x1555] = $A0
                * 执行最后一个Sector对应的上述步骤2和步骤3中的内容。
            7. 完成。
                * 注意，这种情况下完成后，芯片是加锁状态。如果需要解锁，则参考上述步骤4和步骤5。

